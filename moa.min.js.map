{
  "version": 3,
  "file": "D:/Projects/MoaJs/moa.min.js",
  "sources": [
    "Moa.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "sourcesContent": [
    "/**\r\n * Created with WebStorm.\r\n * Project: MoaJs\r\n * User: Sergii Danilov\r\n * Date: 10/31/13\r\n * Time: 6:10 PM\r\n */\r\n/*global define:true, module:true*/\r\n/**\r\n Prototype inheritance and extensions in JavaScript\r\n @module Moa\r\n */\r\n(function () {\r\n    \"use strict\";\r\n    if (!Object.create) {\r\n        Object.create = (function () {\r\n            function F() {}\r\n            return function (o) {\r\n                if (arguments.length !== 1) {\r\n                    throw new Error('Object.create implementation only accepts one parameter.');\r\n                }\r\n                F.prototype = o;\r\n                return new F();\r\n            };\r\n        }());\r\n    }\r\n    var undef,\r\n        fn = 'function',\r\n        ob = 'object',\r\n        un = 'undefined',\r\n        map = {},\r\n        mixins = {},\r\n        extend = function (target, source) {\r\n            var prop;\r\n            for (prop in source) {\r\n                if (source.hasOwnProperty(prop)) {\r\n                    target[prop] = source[prop];\r\n                }\r\n            }\r\n            //Some Object methods are not enumerable on Internet Explorer\r\n            target.toString = source.toString;\r\n            target.valueOf = source.valueOf;\r\n            target.toLocaleString = source.toLocaleString;\r\n            return target;\r\n        },\r\n        throwWrongParamsErr = function (method, param) {\r\n            var msg = 'Wrong parameters in ' + method;\r\n            if (param) {\r\n                msg = 'Wrong parameter ' + param + ' in ' + method;\r\n            }\r\n            throw new Error(msg, 'Moa');\r\n        },\r\n        throwWrongType = function (extendType, isMixin) {\r\n            var type = 'Type ';\r\n            if (isMixin === true) {\r\n                type = 'Mixin type ';\r\n            }\r\n            throw new Error(type + extendType + ' not found', 'Moa');\r\n        },\r\n        addMixins = function ($proto, $mixin) {\r\n            var prop,\r\n                value,\r\n                MixFn;\r\n            for (prop in $mixin) {\r\n                value = $mixin[prop];\r\n                MixFn = mixins[value];\r\n                if (MixFn === undef) {\r\n                    throwWrongType(value, true);\r\n                }\r\n                MixFn.call($proto);\r\n                $proto[prop] = new MixFn();\r\n            }\r\n            return $proto;\r\n        },\r\n        build = function (type, base, definition) {\r\n            var basetype,\r\n                $staticMixin,\r\n                $single = definition.$single,\r\n                $static = definition.$static,\r\n                $mixin = definition.$mixin,\r\n                $ctor = definition.$ctor,\r\n                $base = {};\r\n            if ($ctor !== undef) {\r\n                delete definition.$ctor;\r\n            } else {\r\n                $ctor = function () {};\r\n            }\r\n            delete definition.$single;\r\n            delete definition.$static;\r\n            delete definition.$mixin;\r\n            delete definition.$extend;\r\n            if ($static !== undef) {\r\n                $staticMixin = $static.$mixin;\r\n                if ($staticMixin !== undef) {\r\n                    delete $static.$mixin;\r\n                    addMixins($ctor, $staticMixin);\r\n                }\r\n                extend($ctor, $static);\r\n            }\r\n            if ($mixin !== undef) {\r\n                definition = extend(addMixins({}, $mixin), definition);\r\n            }\r\n            if (base !== undef) {\r\n                basetype = base.$basetype;\r\n                definition = extend(Object.create(base.$ctor.prototype), definition);\r\n            }\r\n            definition.getType = function () {\r\n                return type;\r\n            };\r\n            extend($base, definition);\r\n            $ctor.prototype = definition;\r\n            $ctor.prototype.constructor = $ctor;\r\n            if ($single !== undef && $single === true) {\r\n                (function () {\r\n                    var instance = new $ctor();\r\n                    $ctor = function () {\r\n                        return instance;\r\n                    };\r\n                    $ctor.getInstance = function () {\r\n                        return instance;\r\n                    };\r\n                }());\r\n            }\r\n            $base.$ctor = $ctor;\r\n            return {\r\n                $type: type,\r\n                $basetype: basetype,\r\n                $ctor: $ctor,\r\n                $base: $base\r\n            };\r\n        },\r\n        /**\r\n         @class Moa\r\n        */\r\n        Moa = {\r\n            /**\r\n             * Define new or inherited type\r\n             * @method define\r\n             * @param type {string} name of object type\r\n             * @param definition {Object / Function} implementation of behavior for current type of object. If it is null - delete declared object\r\n             * @return {function} constructor of defined object type\r\n             */\r\n            define: function (type, definition) {\r\n                var mapObj, baseType, base,\r\n                    len = arguments.length;\r\n                switch (len) {\r\n                case 1:\r\n                    mapObj = map[type];\r\n                    if (!mapObj) {\r\n                        throwWrongType(type);\r\n                    }\r\n                    break;\r\n                case 2:\r\n                    switch (typeof definition) {\r\n                    case fn:\r\n                        baseType = definition().$extend;\r\n                        if (baseType !== undef) {\r\n                            base = map[baseType];\r\n                            if (base === undef) {\r\n                                throwWrongType(baseType);\r\n                            }\r\n                            mapObj = build(type, base, definition(base.$base));\r\n                        } else {\r\n                            mapObj = build(type, undef, definition(undef));\r\n                        }\r\n                        break;\r\n                    case ob:\r\n                        if (definition !== null) {\r\n                            baseType = definition.$extend;\r\n                            if (baseType !== undef) {\r\n                                base = map[baseType];\r\n                                if (base === undef) {\r\n                                    throwWrongType(baseType);\r\n                                }\r\n                            }\r\n                            mapObj = build(type, base, definition);\r\n                        } else {\r\n                            delete map[type];\r\n                            return undef;\r\n                        }\r\n                        break;\r\n                    default:\r\n                        throwWrongParamsErr('define', 'definition');\r\n                    }\r\n                    map[type] = mapObj;\r\n                    break;\r\n                default:\r\n                    throwWrongParamsErr('define');\r\n                }\r\n                return mapObj.$ctor;\r\n            },\r\n            /**\r\n             * Declare new mixin type\r\n             * @method mixin\r\n             * @param mixType {string} name of mixin type\r\n             * @param definition {Function} implementation of behavior for mixin.\r\n             */\r\n            mixin: function (mixType, definition) {\r\n                if (typeof definition !== fn) {\r\n                   throwWrongParamsErr('mixin', 'definition');\r\n                }\r\n                mixins[mixType] = definition;\r\n            }\r\n        };\r\n    // Return as AMD module or attach to head object\r\n    if (typeof define !== un) {\r\n        define('Moa',[], function () { return Moa; });\r\n    } else if (typeof window !== un) {\r\n        window.Moa = Moa;\r\n    } else {\r\n        module.exports = Moa;\r\n    }\r\n}());\n"
  ]
}