{
  "version": 3,
  "file": "D:/Projects/MoaJs/moa-noDeps.min.js",
  "sources": [
    "moa-noDeps.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "sourcesContent": [
    "\n/**\r\n * Created with WebStorm.\r\n * Project: MoaJs\r\n * User: Sergii Danilov\r\n * Date: 10/31/13\r\n * Time: 6:10 PM\r\n */\r\n/*global define:true, module:true*/\r\n/**\r\n Prototype inheritance and extensions in JavaScript\r\n @module Moa\r\n */\r\n(function () {\r\n    \"use strict\";\r\n    var map = {},\r\n        extend = function (target, source, isOverride) {\r\n            var prop;\r\n            if (isOverride) {\r\n                for (prop in source) {\r\n                    if (source.hasOwnProperty(prop)) {\r\n                        target[prop] = source[prop];\r\n                    }\r\n                }\r\n            } else {\r\n                for (prop in source) {\r\n                    if (source.hasOwnProperty(prop)) {\r\n                        if (!target[prop]) {\r\n                            target[prop] = source[prop];\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return target;\r\n        },\r\n        fn = 'function',\r\n        notFoundErr = function (type) {\r\n            return new Error('Object \\'' + type + '\\' not found', 'obj');\r\n        },\r\n        wrongParamsErr = function (method) {\r\n            return new Error('Wrong parameters in ' + method, 'obj');\r\n        },\r\n        buildMapObj = function (t, o) {\r\n            var isSingle = o.$isSingle,\r\n                extendType = o.$extend,\r\n                parent,\r\n                prop,\r\n                $proto = {},\r\n                $obj = {},\r\n                $mapObj = {\r\n                    $obj: $obj,\r\n                    $proto: $proto,\r\n                    $extend: extendType,\r\n                    $mixin: o.$mixin,\r\n                    $static: o.$static,\r\n                    $isSingle: isSingle\r\n                };\r\n            delete o.$isSingle;\r\n            delete o.$extend;\r\n            delete o.$mixin;\r\n            delete o.$static;\r\n            for (prop in o) {\r\n                if (o.hasOwnProperty(prop)) {\r\n                    switch (typeof o[prop]) {\r\n                        case fn:\r\n                            $proto[prop] = o[prop];\r\n                            break;\r\n                        default:\r\n                            $obj[prop] = o[prop];\r\n                    }\r\n                }\r\n            }\r\n            if (extendType) {\r\n                parent = map[extendType];\r\n                if (!parent) {\r\n                    throw new Error('Base type not found');\r\n                }\r\n                extend($obj, parent.$obj, false);\r\n                $proto = extend(Object.create(parent.$proto), $proto, true);\r\n                $proto.$base = parent.$constructor;\r\n                $proto.$baseproto = parent.$proto;\r\n                $proto.$getType = function () {\r\n                    return t;\r\n                };\r\n                $mapObj.$proto = $proto;\r\n            }\r\n            $mapObj.$constructor = function () {\r\n                extend(this, $obj, true);\r\n            };\r\n            $mapObj.$constructor.prototype = $proto;\r\n            return $mapObj;\r\n        },\r\n        /**\r\n         @class Moa\r\n        */\r\n        Moa = {\r\n            /**\r\n             * Define new or inherited type\r\n             * @method define\r\n             * @param objName {string} name of object type\r\n             * @param secondParam {Object} implementation of behavior for current type of object. If it is null - delete declared object\r\n             * @return {function} constructor of defined object type\r\n             */\r\n            define: function (objName, secondParam) {\r\n                var me = this,\r\n                    paramsLen = arguments.length,\r\n                    $mapObj;\r\n                switch (paramsLen) {\r\n                case 1:\r\n                    $mapObj = map[objName];\r\n                    if (!$mapObj) {\r\n                        throw notFoundErr(objName);\r\n                    }\r\n                    break;\r\n                case 2:\r\n                    if (secondParam !== null) {\r\n                        $mapObj = buildMapObj(objName, secondParam);\r\n                        map[objName] = $mapObj;\r\n                    } else {\r\n                        delete map[objName];\r\n                        return;\r\n                    }\r\n                    break;\r\n                default:\r\n                    throw wrongParamsErr('define');\r\n                }\r\n                return $mapObj.$constructor;\r\n            },\r\n            /**\r\n             * Factory for new exemplars\r\n             * @method create\r\n             * @param objName {string} name of object type\r\n             * @param mergeObj {object} object for merging with implementing type (with override)\r\n             * @return {object} new exemplar of selected type in first parameter\r\n             */\r\n            create: function (objName, mergeObj) {\r\n                var paramsLen = arguments.length,\r\n                    $mapObj,\r\n                    exemplar;\r\n                switch (paramsLen) {\r\n                case 1:\r\n                    $mapObj = map[objName];\r\n                    if (!$mapObj) {\r\n                        throw notFoundErr(objName);\r\n                    }\r\n                    exemplar = new $mapObj.$constructor();\r\n                    break;\r\n                case 2:\r\n                    $mapObj = map[objName];\r\n                    if (!$mapObj) {\r\n                        throw notFoundErr(objName);\r\n                    }\r\n                    exemplar = new $mapObj.$constructor();\r\n                    extend(exemplar, mergeObj, true);\r\n                    break;\r\n                default:\r\n                    throw wrongParamsErr('create');\r\n                }\r\n                return exemplar;\r\n            }\r\n        };\r\n    // Return as AMD module or attach to head object\r\n    if (typeof define !== 'undefined') {\r\n        define('moa-noDeps',[], function () { return Moa; });\r\n    } else if (typeof window !== 'undefined') {\r\n        window.Moa = Moa;\r\n    } else {\r\n        module.exports = Moa;\r\n    }\r\n}());"
  ]
}